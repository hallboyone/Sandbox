#include <string>
#include <vector>

#ifndef INPUTFLAGS
#define INPUTFLAGS

namespace HB1{
class InputFlags {
public:
  //=============== Custom data types ===============
  /**
   *  Enumeration of the possible flag parameter data types
   */
  enum DataType {NONE=0, INT, DOUBLE, CHAR, STRING};

  /**
   *  Stuct of the information required for a single flag such as its name, 
   *  shorthand char, and its parameter type
   */
  struct CommandLineFlag_{
    std::string name;          /**< Full name of flag. Flag is invoked using --[name]*/
    std::string desc;          /**< Description of flag. Useful for help functions*/
    char sh;                   /**< (opt) The char used for the short hand notation -[sh]*/
    DataType para_t;           /**< (opt) Specify the data type of the parameter. Default is NONE*/
    std::string default_para;  /**< (opt) Default parameter value. Must be empty if para_t is NONE*/
    bool active;               /**< Indicates if the user set the flag*/
    std::string para;          /**< The value of the parameter that the user supplied*/
  };

  typedef struct CommandLineFlag_ CommandLineFlag;
  //================= Constructors ==================
  //InputFlags();

  /** Initializes the object by parseing the flags.tmpl file and user input.
   *  This is a test
   */
  void setFlags(int argc, char ** argv);
private:
  //Members
  std::vector<CommandLineFlag> flags_; // All flags generated by template file
  std::vector<std::string> other_input_; //Any input from argv that could not be matched to flag

  //==================== Methods =====================

  //Parse flags.tmpl and build an array of the possible flags.
  void parseFlagTemplates();

  //Moves forward in the ifstream to the begining of the first '{' not in a comment
  int static move2BlockStart(std::ifstream & f);

  //Finds the next block in the file and saves the valid chars into block
  int static extractNextBlock(std::ifstream & f, std::string & block);

  //Checks if char is one that should be saved from within flag template block
  bool static validBlockChar(const char & c);
  
  //Takes the block template string and uses it to make a new flag
  //Conducts error check to make sure the flag is unique and the para_t and default para match
  void BuildFlag(std::string tmpl_str);
  
  //Finds and varifies the the indicated field from a block template string
  std::string static readName       (std::string & root_string);
  std::string static readDesc       (std::string & root_string);
  char        static readSH         (std::string & root_string);
  DataType    static readPara_t     (std::string & root_string);
  std::string static readDefaultPara(std::string & root_string);
  
  //Finds the key in the string and extracts the chars up to the desired delim char
  int static readKeyValue(const std::string & s, const char * key, size_t len, std::string & val, char delim = ';');

  //Counts the number of leading '-' in the string 
  int static numLeadingDash(const std::string & arg);

  //Reads through an input string vector and converts any sh notation to full names
  std::vector<std::string> formatInputArgs(int argc, char ** argv);

  //Looks for a flag with name matching *it and sets it as active. If needed,
  //the parameter is also read.
  void inputArg2Flag(std::vector<std::string>::iterator & it, const std::vector<std::string>::iterator & args_end);

  //Returns an iterator pointing at the flag with the name 'name'. If none, returns flags_.end()
  std::vector<CommandLineFlag>::iterator getFlagWithName(const std::string & name, bool is_sh);

  bool static verifyIntPara(const std::string & arg);
  bool static verifyDoublePara(const std::string & arg);
  
  void static printFlag(const CommandLineFlag & flag);
};
  
}// namespace HB1

#endif
