#include <stdio.h>
#include <ctype.h>
#include <fstream>
#include <string>
#include <iostream>
#include <limits>//numeric_limits

//Check if char is valid within block
bool validBlockChar(const char & c){
  if(isalpha(c) || c=='=' || c==';' || c=='"') return true;
  else return false;
}

//Finds the first '{' not in a comment
int move2BlockStart(std::ifstream & f){
  char next_char;

  //Move to start of block, skipping any comments or extra chars
  while(f.get(next_char)){
    if(next_char == '{'){
      break;
    }
    else if(next_char == '/' && f.peek()=='/'){
      //Move to end of comment
      f.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    }
  }

  //If no valid open brace was found before EOF
  if(f.eof()) return 0;
  return 1;
}

//Extracts from the ifstream into block until the closing brace
int extractNextBlock(std::ifstream & f, std::string & block){
  if(!move2BlockStart(f)){
    return 0;
  }
  
  char next_char;
  bool in_quotes = false;
  
  block.clear();
  while(f.get(next_char)){
    if(next_char == '"'){
      in_quotes = !in_quotes;
    }

    if(!in_quotes){
      if(next_char == '}'){
	break;
      }
      else if(next_char == '/' && f.peek()=='/'){
	//Move to end of comment
	f.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
      }
      else if(validBlockChar(next_char)){ 
	block.append(&next_char);
      }
    }
    else{
      block.append(&next_char);
    }
  }
  //If no valid open brace was found before EOF
  if(f.eof()) return 0;
  return 1;
}

int readKeyValue(std::string & s, const char * key, size_t len, std::string & val, char delim = ';'){
  
  size_t start_of_key = s.find(key);
  if(start_of_key == std::string::npos){
    return 0;
  }
  size_t start_of_val = start_of_key + len;
  size_t end_of_val = s.find_first_of(delim, start_of_val);
  if(end_of_val == std::string::npos){
    return 0;
  }
  val = s.substr(start_of_val, end_of_val-start_of_val);
  return 1;
}

int Flag(std::string & s){
  std::string name;
  std::string desc;
  std::string sh;
  std::string para;

  //Get name
  if(!readKeyValue(s, "name=", 5, name)) {
    return 0;
  }
  std::cout<<"Name: "<<name<<std::endl;
  
  //Get description
  if(!readKeyValue(s, "desc=\"", 6, desc, '"')) {//with quotes
    if(!readKeyValue(s, "desc=", 5, desc)) {//without quotes
      return 0;
    }
  }
  std::cout<<"Desc: "<<desc<<std::endl;
  
  //Get sh (opt)
  if(readKeyValue(s, "sh=", 3, sh)){
    std::cout<<"Shorthand: "<<sh<<std::endl;
  }
  //Get para type (opt)
  if(readKeyValue(s, "para=", 5, para)){
    std::cout<<"Para Type: "<<para<<std::endl;
  }
  return 1;
}
void parseFlagTemplates(){
  // Open the file
  std::ifstream f ("flags.tmpl");
  std::string nextBlock;
  
  //Extract the next block without any extra chars
  while(extractNextBlock(f, nextBlock)){
    Flag(nextBlock);
  }
  /*
  //Remove all comments, extra whitespace, etc from block
  stripExtraChars(nextBlock);
      
  // | Find the next '{*}'
    std::getline(f, nextBlock, '}');
    size_t startOfBlock = nextBlock.find_first_of("{");
    if(startOfBlock == std::string::npos){
      std::cerr<<"Found closing '}' but no opening\n";
      continue;
    }
    nextBlock.erase(0, startOfBlock+1);
    std::cout<<nextBlock<<std::endl;
    
  }
  // | For each required parameter name
  // | | Find it in the extracted string (Must exist somewhere in string)
  // | | Find the first colon after it (Must be the first non-white space char)
  // | | Extract the parameter value between the colon and the next semi colon
  // | | Save the parameter value into its repective feild in the new flag
  // | Save the new flag
  //== Strip away all non chars not alpha-numeric, ':' or ';'
  //== 
  //== Create a new flag for this group
  //== Read name
  
  
  
  std::string ln;

  
  if(f.is_open()){
    //Get the next line
    while(std::getline(f, ln)){
      
    }
    f.close();
  }
  else{
    std::cout<<"Did not open file."<<std::endl;
  }
  */
  f.close();
}  

int main(int argc, char * argv[]){
  parseFlagTemplates();
  return 1;
}
